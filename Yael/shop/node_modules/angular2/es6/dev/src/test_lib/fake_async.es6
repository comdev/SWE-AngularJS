import {BaseException,
  global} from 'angular2/src/facade/lang';
import {ListWrapper} from 'angular2/src/facade/collection';
var _scheduler;
var _microtasks = [];
var _pendingPeriodicTimers = [];
var _pendingTimers = [];
var _error = null;
export function fakeAsync(fn) {
  var fakeAsyncZone = global.zone.fork({
    setTimeout: _setTimeout,
    clearTimeout: _clearTimeout,
    setInterval: _setInterval,
    clearInterval: _clearInterval,
    scheduleMicrotask: _scheduleMicrotask,
    _inFakeAsyncZone: true
  });
  return function(...args) {
    _scheduler = global.jasmine.DelayedFunctionScheduler();
    ListWrapper.clear(_microtasks);
    ListWrapper.clear(_pendingPeriodicTimers);
    ListWrapper.clear(_pendingTimers);
    var res = fakeAsyncZone.run(() => {
      var res = fn(...args);
    });
    if (_pendingPeriodicTimers.length > 0) {
      throw new BaseException(`${_pendingPeriodicTimers.length} periodic timer(s) still in the queue.`);
    }
    if (_pendingTimers.length > 0) {
      throw new BaseException(`${_pendingTimers.length} timer(s) still in the queue.`);
    }
    _scheduler = null;
    ListWrapper.clear(_microtasks);
    return res;
  };
}
Object.defineProperty(fakeAsync, "parameters", {get: function() {
    return [[Function]];
  }});
export function tick(millis = 0) {
  _assertInFakeAsyncZone();
  flushMicrotasks();
  _scheduler.tick(millis);
}
Object.defineProperty(tick, "parameters", {get: function() {
    return [[assert.type.number]];
  }});
export function flushMicrotasks() {
  _assertInFakeAsyncZone();
  while (_microtasks.length > 0) {
    var microtask = ListWrapper.removeAt(_microtasks, 0);
    microtask();
  }
}
function _setTimeout(fn, delay, ...args) {
  var cb = _fnAndFlush(fn);
  var id = _scheduler.scheduleFunction(cb, delay, args);
  ListWrapper.push(_pendingTimers, id);
  _scheduler.scheduleFunction(_dequeueTimer(id), delay);
  return id;
}
Object.defineProperty(_setTimeout, "parameters", {get: function() {
    return [[Function], [assert.type.number], []];
  }});
function _clearTimeout(id) {
  _dequeueTimer(id);
  return _scheduler.removeFunctionWithId(id);
}
Object.defineProperty(_clearTimeout, "parameters", {get: function() {
    return [[assert.type.number]];
  }});
function _setInterval(fn, interval, ...args) {
  var cb = _fnAndFlush(fn);
  var id = _scheduler.scheduleFunction(cb, interval, args, true);
  _pendingPeriodicTimers.push(id);
  return id;
}
Object.defineProperty(_setInterval, "parameters", {get: function() {
    return [[Function], [assert.type.number], []];
  }});
function _clearInterval(id) {
  ListWrapper.remove(_pendingPeriodicTimers, id);
  return _scheduler.removeFunctionWithId(id);
}
Object.defineProperty(_clearInterval, "parameters", {get: function() {
    return [[assert.type.number]];
  }});
function _fnAndFlush(fn) {
  return () => {
    fn.apply(global, arguments);
    flushMicrotasks();
  };
}
Object.defineProperty(_fnAndFlush, "parameters", {get: function() {
    return [[Function]];
  }});
function _scheduleMicrotask(microtask) {
  ListWrapper.push(_microtasks, microtask);
}
Object.defineProperty(_scheduleMicrotask, "parameters", {get: function() {
    return [[Function]];
  }});
function _dequeueTimer(id) {
  return function() {
    ListWrapper.remove(_pendingTimers, id);
  };
}
Object.defineProperty(_dequeueTimer, "parameters", {get: function() {
    return [[assert.type.number]];
  }});
function _assertInFakeAsyncZone() {
  if (!global.zone._inFakeAsyncZone) {
    throw new Error('The code should be running in the fakeAsync zone to call this function');
  }
}
//# sourceMappingURL=fake_async.es6.map

//# sourceMappingURL=./fake_async.map