import {Binding,
  resolveForwardRef} from 'angular2/di';
import {Injectable} from 'angular2/src/di/annotations_impl';
import {Type,
  isBlank,
  isPresent,
  BaseException,
  normalizeBlank,
  stringify} from 'angular2/src/facade/lang';
import {Promise,
  PromiseWrapper} from 'angular2/src/facade/async';
import {List,
  ListWrapper,
  Map,
  MapWrapper} from 'angular2/src/facade/collection';
import {DirectiveResolver} from './directive_resolver';
import {AppProtoView} from './view';
import {ElementBinder} from './element_binder';
import {ProtoViewRef} from './view_ref';
import {DirectiveBinding} from './element_injector';
import {TemplateResolver} from './template_resolver';
import {View} from '../annotations_impl/view';
import {ComponentUrlMapper} from './component_url_mapper';
import {ProtoViewFactory} from './proto_view_factory';
import {UrlResolver} from 'angular2/src/services/url_resolver';
import * as renderApi from 'angular2/src/render/api';
export class CompilerCache {
  constructor() {
    this._cache = MapWrapper.create();
  }
  set(component, protoView) {
    MapWrapper.set(this._cache, component, protoView);
  }
  get(component) {
    var result = MapWrapper.get(this._cache, component);
    return normalizeBlank(result);
  }
  clear() {
    MapWrapper.clear(this._cache);
  }
}
Object.defineProperty(CompilerCache, "annotations", {get: function() {
    return [new Injectable()];
  }});
Object.defineProperty(CompilerCache.prototype.set, "parameters", {get: function() {
    return [[Type], [AppProtoView]];
  }});
Object.defineProperty(CompilerCache.prototype.get, "parameters", {get: function() {
    return [[Type]];
  }});
export class Compiler {
  constructor(reader, cache, templateResolver, componentUrlMapper, urlResolver, render, protoViewFactory) {
    this._reader = reader;
    this._compilerCache = cache;
    this._compiling = MapWrapper.create();
    this._templateResolver = templateResolver;
    this._componentUrlMapper = componentUrlMapper;
    this._urlResolver = urlResolver;
    this._appUrl = urlResolver.resolve(null, './');
    this._render = render;
    this._protoViewFactory = protoViewFactory;
  }
  _bindDirective(directiveTypeOrBinding) {
    if (directiveTypeOrBinding instanceof DirectiveBinding) {
      return directiveTypeOrBinding;
    } else if (directiveTypeOrBinding instanceof Binding) {
      let annotation = this._reader.resolve(directiveTypeOrBinding.token);
      return DirectiveBinding.createFromBinding(directiveTypeOrBinding, annotation);
    } else {
      let annotation = this._reader.resolve(directiveTypeOrBinding);
      return DirectiveBinding.createFromType(directiveTypeOrBinding, annotation);
    }
  }
  compileInHost(componentTypeOrBinding) {
    var componentBinding = this._bindDirective(componentTypeOrBinding);
    Compiler._assertTypeIsComponent(componentBinding);
    var directiveMetadata = componentBinding.metadata;
    return this._render.compileHost(directiveMetadata).then((hostRenderPv) => {
      return this._compileNestedProtoViews(componentBinding, hostRenderPv, [componentBinding]);
    }).then((appProtoView) => {
      return new ProtoViewRef(appProtoView);
    });
  }
  compile(component) {
    var componentBinding = this._bindDirective(component);
    Compiler._assertTypeIsComponent(componentBinding);
    var protoView = this._compile(componentBinding);
    var pvPromise = PromiseWrapper.isPromise(protoView) ? protoView : PromiseWrapper.resolve(protoView);
    return pvPromise.then((appProtoView) => {
      return new ProtoViewRef(appProtoView);
    });
  }
  _compile(componentBinding) {
    var component = componentBinding.key.token;
    var protoView = this._compilerCache.get(component);
    if (isPresent(protoView)) {
      return protoView;
    }
    var pvPromise = MapWrapper.get(this._compiling, component);
    if (isPresent(pvPromise)) {
      return pvPromise;
    }
    var template = this._templateResolver.resolve(component);
    if (isBlank(template)) {
      return null;
    }
    var directives = this._flattenDirectives(template);
    for (var i = 0; i < directives.length; i++) {
      if (!Compiler._isValidDirective(directives[i])) {
        throw new BaseException(`Unexpected directive value '${stringify(directives[i])}' on the View of component '${stringify(component)}'`);
      }
    }
    var boundDirectives = ListWrapper.map(directives, (directive) => this._bindDirective(directive));
    var renderTemplate = this._buildRenderTemplate(component, template, boundDirectives);
    pvPromise = this._render.compile(renderTemplate).then((renderPv) => {
      return this._compileNestedProtoViews(componentBinding, renderPv, boundDirectives);
    });
    MapWrapper.set(this._compiling, component, pvPromise);
    return pvPromise;
  }
  _compileNestedProtoViews(componentBinding, renderPv, directives) {
    var protoViews = this._protoViewFactory.createAppProtoViews(componentBinding, renderPv, directives);
    var protoView = protoViews[0];
    if (renderPv.type === renderApi.ProtoViewDto.COMPONENT_VIEW_TYPE && isPresent(componentBinding)) {
      var component = componentBinding.key.token;
      this._compilerCache.set(component, protoView);
      MapWrapper.delete(this._compiling, component);
    }
    var nestedPVPromises = [];
    ListWrapper.forEach(this._collectComponentElementBinders(protoViews), (elementBinder) => {
      var nestedComponent = elementBinder.componentDirective;
      var elementBinderDone = (nestedPv) => {
        elementBinder.nestedProtoView = nestedPv;
      };
      var nestedCall = this._compile(nestedComponent);
      if (PromiseWrapper.isPromise(nestedCall)) {
        ListWrapper.push(nestedPVPromises, nestedCall.then(elementBinderDone));
      } else if (isPresent(nestedCall)) {
        elementBinderDone(nestedCall);
      }
    });
    var protoViewDone = (_) => {
      return protoView;
    };
    if (nestedPVPromises.length > 0) {
      return PromiseWrapper.all(nestedPVPromises).then(protoViewDone);
    } else {
      return protoViewDone(null);
    }
  }
  _collectComponentElementBinders(protoViews) {
    var componentElementBinders = [];
    ListWrapper.forEach(protoViews, (protoView) => {
      ListWrapper.forEach(protoView.elementBinders, (elementBinder) => {
        if (isPresent(elementBinder.componentDirective)) {
          ListWrapper.push(componentElementBinders, elementBinder);
        }
      });
    });
    return componentElementBinders;
  }
  _buildRenderTemplate(component, view, directives) {
    var componentUrl = this._urlResolver.resolve(this._appUrl, this._componentUrlMapper.getUrl(component));
    var templateAbsUrl = null;
    if (isPresent(view.templateUrl)) {
      templateAbsUrl = this._urlResolver.resolve(componentUrl, view.templateUrl);
    } else if (isPresent(view.template)) {
      templateAbsUrl = componentUrl;
    }
    return new renderApi.ViewDefinition({
      componentId: stringify(component),
      absUrl: templateAbsUrl,
      template: view.template,
      directives: ListWrapper.map(directives, (directiveBinding) => directiveBinding.metadata)
    });
  }
  _flattenDirectives(template) {
    if (isBlank(template.directives))
      return [];
    var directives = [];
    this._flattenList(template.directives, directives);
    return directives;
  }
  _flattenList(tree, out) {
    for (var i = 0; i < tree.length; i++) {
      var item = resolveForwardRef(tree[i]);
      if (ListWrapper.isList(item)) {
        this._flattenList(item, out);
      } else {
        ListWrapper.push(out, item);
      }
    }
  }
  static _isValidDirective(value) {
    return isPresent(value) && (value instanceof Type || value instanceof Binding);
  }
  static _assertTypeIsComponent(directiveBinding) {
    if (directiveBinding.metadata.type !== renderApi.DirectiveMetadata.COMPONENT_TYPE) {
      throw new BaseException(`Could not load '${stringify(directiveBinding.key.token)}' because it is not a component.`);
    }
  }
}
Object.defineProperty(Compiler, "annotations", {get: function() {
    return [new Injectable()];
  }});
Object.defineProperty(Compiler, "parameters", {get: function() {
    return [[DirectiveResolver], [CompilerCache], [TemplateResolver], [ComponentUrlMapper], [UrlResolver], [renderApi.RenderCompiler], [ProtoViewFactory]];
  }});
Object.defineProperty(Compiler.prototype.compileInHost, "parameters", {get: function() {
    return [[assert.type.any]];
  }});
Object.defineProperty(Compiler.prototype.compile, "parameters", {get: function() {
    return [[Type]];
  }});
Object.defineProperty(Compiler.prototype._compile, "parameters", {get: function() {
    return [[DirectiveBinding]];
  }});
Object.defineProperty(Compiler.prototype._collectComponentElementBinders, "parameters", {get: function() {
    return [[assert.genericType(List, AppProtoView)]];
  }});
Object.defineProperty(Compiler.prototype._flattenDirectives, "parameters", {get: function() {
    return [[View]];
  }});
Object.defineProperty(Compiler.prototype._flattenList, "parameters", {get: function() {
    return [[assert.genericType(List, assert.type.any)], [assert.genericType(List, assert.type.any)]];
  }});
Object.defineProperty(Compiler._isValidDirective, "parameters", {get: function() {
    return [[assert.type.any]];
  }});
Object.defineProperty(Compiler._assertTypeIsComponent, "parameters", {get: function() {
    return [[DirectiveBinding]];
  }});
//# sourceMappingURL=compiler.js.map

//# sourceMappingURL=./compiler.map